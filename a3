import logging
import aiohttp
import asyncio
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
)

TELEGRAM_BOT_TOKEN = "8386168923:AAF_A4PFMENBifwwEhTHjLQe9Y6Vk3h9pzo"
CHANNEL_CHAT_ID = "-1002928327769"

BASE_URL = "https://api.bitpin.org/api/v1"

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

markets_cache = []
tickers_cache = []

async def fetch_json(url):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as resp:
                resp.raise_for_status()
                return await resp.json()
    except Exception as e:
        logger.error(f"Error fetching {url}: {e}")
        return None

async def get_markets():
    global markets_cache
    data = await fetch_json(f"{BASE_URL}/mkt/markets/")
    if data:
        markets_cache = [m for m in data if m["quote"] == "IRT" and m["tradable"]]
    return markets_cache

async def get_tickers():
    global tickers_cache
    data = await fetch_json(f"{BASE_URL}/mkt/tickers/")
    if data:
        tickers_cache = data
    return tickers_cache

async def get_best_bid_ask(symbol):
    data = await fetch_json(f"{BASE_URL}/mth/orderbook/{symbol}/")
    if data:
        best_bid = float(data["bids"][0][0]) if data["bids"] else None
        best_ask = float(data["asks"][0][0]) if data["asks"] else None
        return best_bid, best_ask
    return None, None

def format_price_irt(price):
    if price is None:
        return "Ù†Ø§Ù…Ø´Ø®Øµ"
    return f"{price:,.0f} ØªÙˆÙ…Ø§Ù†"

async def build_price_messages():
    markets = await get_markets()
    tickers = await get_tickers()
    if not markets or not tickers:
        return ["Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±."]

    ticker_dict = {item["symbol"]: float(item["price"]) for item in tickers}
    messages = []
    current_message = []
    count = 0

    for m in markets:
        symbol = m["symbol"]
        if symbol not in ticker_dict:
            continue
        best_bid, best_ask = await get_best_bid_ask(symbol)
        if best_bid is None or best_ask is None:
            continue
        spread = best_ask - best_bid

        msg_part = (
            f"ğŸ’° {symbol}\n"
            f"Ø®Ø±ÛŒØ¯ (Bid): {format_price_irt(best_bid)}\n"
            f"ÙØ±ÙˆØ´ (Ask): {format_price_irt(best_ask)}\n"
            f"ğŸ“‰ Ø§Ø®ØªÙ„Ø§Ù Ù‚ÛŒÙ…Øª: {format_price_irt(spread)}\n"
            "-----------------------------"
        )
        current_message.append(msg_part)
        count += 1

        if count == 10:
            messages.append("\n".join(current_message))
            current_message = []
            count = 0

    if current_message:
        messages.append("\n".join(current_message))

    return messages

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Ø³Ù„Ø§Ù…! Ù…Ù† Ø¨Ø§Øª Ø¨Ø§Ø²Ø§Ø± Ú©Ø±ÛŒÙ¾ØªÙˆ Ø¨ÛŒØªâ€ŒÙ¾ÛŒÙ† Ù‡Ø³ØªÙ….\n"
        "Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øª Ø¨Ù‡ØªØ±ÛŒÙ† Ø®Ø±ÛŒØ¯Ø§Ø±Ø§Ù† Ùˆ ÙØ±ÙˆØ´Ù†Ø¯Ú¯Ø§Ù† Ù‡Ø± Ø§Ø±Ø²ØŒ Ù†Ù…Ø§Ø¯ Ø§Ø±Ø² Ø±Ùˆ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†. Ù…Ø«Ø§Ù„: BTC"
    )

async def handle_symbol(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip().upper()
    markets = markets_cache or await get_markets()
    matched = [m for m in markets if m["base"] == text and m["quote"] == "IRT"]
    if not matched:
        await update.message.reply_text(f"Ø§Ø±Ø² {text} Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± Ø±ÛŒØ§Ù„ÛŒ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.")
        return

    symbol = matched[0]["symbol"]
    best_bid, best_ask = await get_best_bid_ask(symbol)
    if best_bid is None or best_ask is None:
        await update.message.reply_text("Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§.")
        return
    spread = best_ask - best_bid
    
    message = (
        f"ğŸ’° Ù‚ÛŒÙ…Øª {symbol} Ø¯Ø± Ø¨Ø§Ø²Ø§Ø± Ø±ÛŒØ§Ù„ÛŒ:\n"
        f"Ø®Ø±ÛŒØ¯ (Bid): {format_price_irt(best_bid)}\n"
        f"ÙØ±ÙˆØ´ (Ask): {format_price_irt(best_ask)}\n"
        f"ğŸ“‰ Ø§Ø®ØªÙ„Ø§Ù Ù‚ÛŒÙ…Øª: {format_price_irt(spread)}"
    )
    await update.message.reply_text(message)

async def scheduled_price_update(app):
    while True:
        messages = await build_price_messages()
        try:
            for msg in messages:
                await app.bot.send_message(chat_id=CHANNEL_CHAT_ID, text=msg)
                await asyncio.sleep(2)
            logger.info("Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù†Ø¯.")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„: {e}")
        await asyncio.sleep(600)

async def main():
    app = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_symbol))

    # Ù„ÙˆØ¯ Ø§ÙˆÙ„ÛŒÙ‡ Ú©Ø´â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ø³Ø±Ø¹Øª
    await get_markets()
    await get_tickers()

    # ØªØ³Ú© Ø§Ø±Ø³Ø§Ù„ Ù‚ÛŒÙ…Øªâ€ŒÙ‡Ø§ Ø¨Ù‡ Ú©Ø§Ù†Ø§Ù„
    asyncio.create_task(scheduled_price_update(app))

    await app.run_polling()

if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()
    asyncio.run(main())

