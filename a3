import logging
import aiohttp
import asyncio
from telegram import Update
from telegram.ext import (
    ApplicationBuilder,
    ContextTypes,
    CommandHandler,
    MessageHandler,
    filters,
)

TELEGRAM_BOT_TOKEN = "8386168923:AAF_A4PFMENBifwwEhTHjLQe9Y6Vk3h9pzo"
CHANNEL_CHAT_ID = "-1002928327769"

BASE_URL = "https://api.bitpin.org/api/v1"

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

markets_cache = []
tickers_cache = []

async def fetch_json(url):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=10) as resp:
                resp.raise_for_status()
                return await resp.json()
    except Exception as e:
        logger.error(f"Error fetching {url}: {e}")
        return None

async def get_markets():
    global markets_cache
    data = await fetch_json(f"{BASE_URL}/mkt/markets/")
    if data:
        markets_cache = [m for m in data if m["quote"] == "IRT" and m["tradable"]]
    return markets_cache

async def get_tickers():
    global tickers_cache
    data = await fetch_json(f"{BASE_URL}/mkt/tickers/")
    if data:
        tickers_cache = data
    return tickers_cache

async def get_best_bid_ask(symbol):
    data = await fetch_json(f"{BASE_URL}/mth/orderbook/{symbol}/")
    if data:
        best_bid = float(data["bids"][0][0]) if data["bids"] else None
        best_ask = float(data["asks"][0][0]) if data["asks"] else None
        return best_bid, best_ask
    return None, None

def format_price_irt(price):
    if price is None:
        return "نامشخص"
    return f"{price:,.0f} تومان"

async def build_price_messages():
    markets = await get_markets()
    tickers = await get_tickers()
    if not markets or not tickers:
        return ["خطا در دریافت داده‌های بازار."]

    ticker_dict = {item["symbol"]: float(item["price"]) for item in tickers}
    messages = []
    current_message = []
    count = 0

    for m in markets:
        symbol = m["symbol"]
        if symbol not in ticker_dict:
            continue
        best_bid, best_ask = await get_best_bid_ask(symbol)
        if best_bid is None or best_ask is None:
            continue
        spread = best_ask - best_bid

        msg_part = (
            f"💰 {symbol}\n"
            f"خرید (Bid): {format_price_irt(best_bid)}\n"
            f"فروش (Ask): {format_price_irt(best_ask)}\n"
            f"📉 اختلاف قیمت: {format_price_irt(spread)}\n"
            "-----------------------------"
        )
        current_message.append(msg_part)
        count += 1

        if count == 10:
            messages.append("\n".join(current_message))
            current_message = []
            count = 0

    if current_message:
        messages.append("\n".join(current_message))

    return messages

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "سلام! من بات بازار کریپتو بیت‌پین هستم.\n"
        "برای دریافت قیمت بهترین خریداران و فروشندگان هر ارز، نماد ارز رو ارسال کن. مثال: BTC"
    )

async def handle_symbol(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip().upper()
    markets = markets_cache or await get_markets()
    matched = [m for m in markets if m["base"] == text and m["quote"] == "IRT"]
    if not matched:
        await update.message.reply_text(f"ارز {text} در بازار ریالی پیدا نشد.")
        return

    symbol = matched[0]["symbol"]
    best_bid, best_ask = await get_best_bid_ask(symbol)
    if best_bid is None or best_ask is None:
        await update.message.reply_text("خطا در دریافت قیمت‌ها.")
        return
    spread = best_ask - best_bid
    
    message = (
        f"💰 قیمت {symbol} در بازار ریالی:\n"
        f"خرید (Bid): {format_price_irt(best_bid)}\n"
        f"فروش (Ask): {format_price_irt(best_ask)}\n"
        f"📉 اختلاف قیمت: {format_price_irt(spread)}"
    )
    await update.message.reply_text(message)

async def scheduled_price_update(app):
    while True:
        messages = await build_price_messages()
        try:
            for msg in messages:
                await app.bot.send_message(chat_id=CHANNEL_CHAT_ID, text=msg)
                await asyncio.sleep(2)
            logger.info("پیام‌های قیمت‌ها به کانال ارسال شدند.")
        except Exception as e:
            logger.error(f"خطا در ارسال پیام به کانال: {e}")
        await asyncio.sleep(600)

async def main():
    app = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_symbol))

    # لود اولیه کش‌ها برای افزایش سرعت
    await get_markets()
    await get_tickers()

    # تسک ارسال قیمت‌ها به کانال
    asyncio.create_task(scheduled_price_update(app))

    await app.run_polling()

if __name__ == "__main__":
    import nest_asyncio
    nest_asyncio.apply()
    asyncio.run(main())

